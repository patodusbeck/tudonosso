const {
  ActionRowBuilder,
  PermissionFlagsBits,
  ButtonBuilder,
  ButtonStyle,
  EmbedBuilder,
  ModalBuilder,
  TextInputBuilder,
  TextInputStyle
} = require('discord.js');

const TicketSchema = require('../../Schemas/Ticket');
const STAFF_ROLE_ID = '1079207706050691119';
const config = require('../../config');
const { createTranscript } = require('discord-html-transcripts');
const TicketSetup = require('../../Schemas/TicketSetup');

module.exports = async (interaction) => {

  // ğŸ”’ PERMISSÃƒO STAFF
  if (!interaction.member.roles.cache.has(STAFF_ROLE_ID)) {
    return interaction.reply({
      content: 'âŒ VocÃª nÃ£o tem permissÃ£o para usar o Painel Staff.',
      ephemeral: true
    });
  }

  // ğŸ”’ ABRIR PAINEL STAFF
  if (interaction.customId === 'staff_panel') {
    const embed = new EmbedBuilder()
      .setColor('#2f3136')
      .setTitle('ğŸ”’ PAINEL ADMINISTRATIVO DO TICKET')
      .setDescription(
        `OlÃ¡ ${interaction.member}, seja bem-vindo ao painel administrativo do ticket.\n` +
        `Aqui vocÃª encontrarÃ¡ todas as opÃ§Ãµes de gerenciamento do ticket,\n` +
        `caso haja alguma dÃºvida informe com os responsÃ¡veis.`
      );

    const row = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('staff_notify')
        .setLabel('ğŸ”” Notificar Membro')
        .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
        .setCustomId('staff_close')
        .setLabel('âŒ Fechar Ticket')
        .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
        .setCustomId('staff_rename_channel')
        .setLabel('âœï¸ Renomear Canal')
        .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
        .setCustomId('ticket_claim')
        .setLabel('Assumir ')
        .setStyle(ButtonStyle.Success)
    );

    return interaction.reply({
      embeds: [embed],
      components: [row],
      ephemeral: true
    });
  }

  // ğŸ”” MENU DE NOTIFICAÃ‡ÃƒO
  if (interaction.customId === 'staff_notify') {
    const embed = new EmbedBuilder()
      .setColor('#2f3136')
      .setTitle('ğŸ”” Notificar Solicitante')
      .setDescription('Escolha como deseja notificar o solicitante do ticket.');

    const row = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('staff_notify_auto')
        .setLabel('ğŸ“¨ Mensagem AutomÃ¡tica')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('staff_notify_manual')
        .setLabel('âœï¸ Mensagem Manual')
        .setStyle(ButtonStyle.Primary)
    );

    return interaction.reply({
      embeds: [embed],
      components: [row],
      ephemeral: true
    });
  }
    // âœï¸ RENOMEAR CANAL
  if (interaction.customId === 'staff_rename_channel') {
    const modal = new ModalBuilder()
      .setCustomId('staff_rename_modal')
      .setTitle('Renomear Canal');

    const input = new TextInputBuilder()
      .setCustomId('new_channel_name')
      .setLabel('Novo nome do canal')
      .setStyle(TextInputStyle.Short)
      .setRequired(true);

    modal.addComponents(new ActionRowBuilder().addComponents(input));
    return interaction.showModal(modal);
  }

  if (interaction.customId === 'staff_rename_modal') {
    const newName = interaction.fields.getTextInputValue('new_channel_name');
    await interaction.channel.setName(newName);

    return interaction.reply({
      content: `âœ… Canal renomeado para **${newName}**.`,
      ephemeral: true
    });
  }

  // ğŸ“¨ NOTIFICAÃ‡ÃƒO AUTOMÃTICA
  if (interaction.customId === 'staff_notify_auto') {
    const ticket = await TicketSchema.findOne({
      GuildID: interaction.guild.id,
      ChannelID: interaction.channel.id
    });
    if (!ticket) return;

    const user = await interaction.client.users.fetch(ticket.OwnerID);

    await user.send(
      `ğŸ”” **AtualizaÃ§Ã£o no seu ticket**\n\n` +
      `Nossa equipe respondeu e aguarda seu retorno no ticket:\n` +
      `${interaction.channel}`
    );

    return interaction.reply({
      content: 'âœ… Mensagem automÃ¡tica enviada ao solicitante.',
      ephemeral: true
    });
  }

  // âœï¸ MODAL DE MENSAGEM MANUAL
  if (interaction.customId === 'staff_notify_manual') {
    const modal = new ModalBuilder()
      .setCustomId('staff_notify_modal')
      .setTitle('Mensagem Manual');

    const input = new TextInputBuilder()
      .setCustomId('notify_message')
      .setLabel('Mensagem que serÃ¡ enviada ao solicitante')
      .setStyle(TextInputStyle.Paragraph)
      .setRequired(true);

    modal.addComponents(
      new ActionRowBuilder().addComponents(input)
    );

    return interaction.showModal(modal);
  }

  // ğŸ“© ENVIAR MENSAGEM MANUAL
  if (interaction.customId === 'staff_notify_modal') {
    const message = interaction.fields.getTextInputValue('notify_message');

    const ticket = await TicketSchema.findOne({
      GuildID: interaction.guild.id,
      ChannelID: interaction.channel.id
    });
    if (!ticket) return;

    const user = await interaction.client.users.fetch(ticket.OwnerID);

    await user.send(
      `ğŸ”” **Mensagem da equipe de suporte**\n\n${message}`
    );

    return interaction.reply({
      content: 'âœ… Mensagem manual enviada com sucesso.',
      ephemeral: true
    });
  }
// âŒ FINALIZAR TICKET
if (interaction.customId !== 'staff_close') return;

const { guild, channel } = interaction;

// responde a interaÃ§Ã£o UMA ÃšNICA VEZ
await interaction.deferUpdate();

const data = await TicketSchema.findOne({
  GuildID: guild.id,
  ChannelID: channel.id
});
if (!data) return;

const docs = await TicketSetup.findOne({ GuildID: guild.id });
if (!docs) return;

// ğŸ“„ TRANSCRIPT
const transcript = await createTranscript(channel, {
  limit: -1,
  returnType: 'attachment',
  saveImages: true,
  poweredBy: false,
  filename: `${config.ticketName}${data.TicketID}.html`
});

const claimed = data.Claimed ? 'âœ…' : 'âŒ';
const claimedBy = data.ClaimedBy ? `<@${data.ClaimedBy}>` : 'âŒ';
const timestamp = Math.round(Date.now() / 1000);

const transcriptEmbed = new EmbedBuilder().setDescription(
  `${config.ticketTranscriptMember} <@${data.OwnerID}>\n` +
  `${config.ticketTranscriptTicket} ${data.TicketID}\n` +
  `${config.ticketTranscriptClaimed} ${claimed}\n` +
  `${config.ticketTranscriptModerator} ${claimedBy}\n` +
  `${config.ticketTranscriptTime} <t:${timestamp}:F>`
);

// ğŸ“‚ ENVIAR TRANSCRIPT
await guild.channels.cache.get(docs.Transcripts)?.send({
  embeds: [transcriptEmbed],
  files: [transcript]
});

// ğŸ”’ AVISO NO CANAL
await channel.send({
  embeds: [
    new EmbedBuilder()
      .setTitle(config.ticketCloseTitle)
      .setDescription(config.ticketCloseDescription)
      .setColor(config.color)
  ]
});

// ğŸ—‘ï¸ REMOVER DO BANCO
await TicketSchema.deleteOne({
  GuildID: guild.id,
  ChannelID: channel.id
});

// â³ DELETAR CANAL
setTimeout(() => {
  channel.delete().catch(() => {});
}, 5000);












    // ğŸ·ï¸ CLAIMAR TICKET
if (interaction.customId === 'ticket_claim') {

  // âœ… responde a interaÃ§Ã£o imediatamente (EVITA "a interaÃ§Ã£o falhou")
  await interaction.deferUpdate();

  const { guild, channel, member } = interaction;

  // ğŸ” buscar ticket no banco
  const data = await TicketSchema.findOne({
    GuildID: guild.id,
    ChannelID: channel.id
  });

  // se nÃ£o existir, apenas encerra (interaÃ§Ã£o jÃ¡ foi respondida)
  if (!data) return;

  // âŒ ticket jÃ¡ claimado
  if (data.Claimed) {
    await channel.send({
      embeds: [
        new EmbedBuilder()
          .setColor(config.color)
          .setDescription(
            `${config.ticketAlreadyClaim} <@${data.ClaimedBy}>`
          )
      ]
    });
    return;
  }

  // âœ… marcar como claimado
  await TicketSchema.updateOne(
    { GuildID: guild.id, ChannelID: channel.id },
    { Claimed: true, ClaimedBy: member.id }
  );

  // âœï¸ atualizar nome do canal
  await channel.edit({
    name: `${config.ticketCheck}ãƒ»${channel.name}`
  });

  // ğŸ“¢ aviso no ticket
  await channel.send({
    embeds: [
      new EmbedBuilder()
        .setColor(config.color)
        .setTitle('Central de Suporte')
        .setDescription(config.ticketSuccessClaim)
    ]
  });

  return;
}


};
